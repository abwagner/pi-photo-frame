<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="csrf-token" content="{{ csrf_token() }}">
    <title>Pi Photo Frame</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header-top {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-bottom: 10px;
        }

        .header-link {
            color: #888;
            text-decoration: none;
            font-size: 0.9rem;
            transition: color 0.2s;
        }

        .header-link:hover {
            color: #00d4ff;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #00d4ff, #7b2cbf);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            color: #888;
        }

        .display-link {
            display: inline-block;
            margin-top: 15px;
            padding: 10px 25px;
            background: linear-gradient(90deg, #7b2cbf, #00d4ff);
            color: white;
            text-decoration: none;
            border-radius: 25px;
            font-weight: 500;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .display-link:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(123, 44, 191, 0.4);
        }

        /* ===== Preview Section ===== */
        .preview-section {
            display: none;
            margin-bottom: 20px;
        }

        .preview-section.active {
            display: block;
        }

        .mat-preview {
            width: 100%;
            aspect-ratio: var(--preview-aspect-ratio, 16/9);
            border-radius: 16px 16px 0 0;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.4);
        }

        .preview-section:not(.has-controls) .mat-preview {
            border-radius: 16px;
        }

        #preview-content {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .mat-preview img {
            max-width: 90%;
            max-height: 90%;
            object-fit: contain;
        }

        /* Crop overlay */
        .crop-overlay {
            position: absolute;
            inset: 0;
            z-index: 20;
        }

        .crop-selection {
            position: absolute;
            border: 2px dashed #00d4ff;
            cursor: move;
            box-shadow: 0 0 0 9999px rgba(0, 0, 0, 0.5);
            z-index: 21;
        }

        .crop-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: #00d4ff;
            border-radius: 50%;
            z-index: 22;
        }

        .crop-handle.nw { top: -7px; left: -7px; cursor: nw-resize; }
        .crop-handle.ne { top: -7px; right: -7px; cursor: ne-resize; }
        .crop-handle.sw { bottom: -7px; left: -7px; cursor: sw-resize; }
        .crop-handle.se { bottom: -7px; right: -7px; cursor: se-resize; }
        .crop-handle.n  { top: -7px; left: calc(50% - 7px); cursor: n-resize; }
        .crop-handle.s  { bottom: -7px; left: calc(50% - 7px); cursor: s-resize; }
        .crop-handle.e  { top: calc(50% - 7px); right: -7px; cursor: e-resize; }
        .crop-handle.w  { top: calc(50% - 7px); left: -7px; cursor: w-resize; }

        .crop-toolbar {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 25;
        }

        .crop-toolbar .btn {
            padding: 8px 20px;
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Bevel wrapper in preview - V-groove cut, lit from above */
        .mat-preview .mat-bevel {
            position: relative;
            display: inline-flex;
            line-height: 0;
            overflow: hidden;
            padding: var(--bevel-w, 4px);
            /* Light from above: top face shadowed, bottom face lit */
            background: linear-gradient(to bottom, var(--bevel-dark, rgba(0,0,0,0.10)), var(--bevel-light, rgba(255,255,255,0.04)));
        }
        /* Subtle shadow cast by top bevel onto the image */
        .mat-preview .mat-bevel::after {
            content: '';
            position: absolute;
            top: var(--bevel-w, 4px);
            left: var(--bevel-w, 4px);
            right: var(--bevel-w, 4px);
            bottom: var(--bevel-w, 4px);
            pointer-events: none;
            z-index: 3;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.10);
        }
        .mat-preview .mat-bevel img {
            box-shadow: none;
            display: block;
            max-width: none;
            max-height: none;
        }

        /* Shadow effect wrapper in preview */
        .mat-preview .mat-shadow {
            display: inline-flex;
            line-height: 0;
        }
        .mat-preview .mat-shadow img {
            display: block;
            max-width: none;
            max-height: none;
        }

        /* Texture overlays on preview */
        .mat-preview::before {
            content: '';
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 0;
            opacity: 0;
            border-radius: inherit;
        }
        .mat-preview.mat-linen::before {
            background-image: url("data:image/svg+xml,%3Csvg width='8' height='8' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0h8M0 4h8M0 0v8M4 0v8' stroke='%23888' stroke-width='0.3' fill='none'/%3E%3C/svg%3E");
            background-size: 8px 8px;
            opacity: 0.08;
        }
        .mat-preview.mat-suede::before {
            background-image: url("data:image/svg+xml,%3Csvg width='6' height='6' xmlns='http://www.w3.org/2000/svg'%3E%3Ccircle cx='1' cy='1' r='0.6' fill='%23888'/%3E%3Ccircle cx='4' cy='3' r='0.4' fill='%23888'/%3E%3Ccircle cx='2' cy='5' r='0.5' fill='%23888'/%3E%3Ccircle cx='5' cy='1' r='0.3' fill='%23888'/%3E%3C/svg%3E");
            background-size: 6px 6px;
            opacity: 0.06;
        }
        .mat-preview.mat-silk::before {
            background-image: url("data:image/svg+xml,%3Csvg width='10' height='10' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 10L10 0' stroke='%23888' stroke-width='0.4' fill='none'/%3E%3Cpath d='M-2 2L2 -2M8 12L12 8' stroke='%23888' stroke-width='0.3' fill='none'/%3E%3C/svg%3E");
            background-size: 10px 10px;
            opacity: 0.06;
        }

        .preview-close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            background: rgba(0, 0, 0, 0.5);
            color: rgba(255, 255, 255, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            font-size: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            transition: background 0.2s;
        }

        .preview-close-btn:hover {
            background: rgba(0, 0, 0, 0.7);
        }

        /* Preview controls bar (below the image) */
        .preview-controls {
            display: none;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-top: none;
            border-radius: 0 0 16px 16px;
            padding: 16px;
            backdrop-filter: blur(10px);
        }

        .preview-controls.active {
            display: block;
        }

        .preview-controls-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .preview-controls-header h3 {
            font-size: 0.9rem;
            color: #e0e0e0;
            font-weight: 500;
        }

        .preview-controls-actions {
            display: flex;
            gap: 6px;
        }

        .btn-refresh {
            background: rgba(0, 212, 255, 0.15);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        /* ===== Main Layout ===== */
        .panels {
            display: grid;
            grid-template-columns: 1fr 300px;
            grid-template-rows: auto 1fr;
            gap: 20px;
        }

        .main-upload-section {
            grid-column: 1;
            grid-row: 1;
        }

        .main-gallery-section {
            grid-column: 1;
            grid-row: 2;
        }

        .settings-column {
            grid-column: 2;
            grid-row: 1 / -1;
        }

        @media (max-width: 900px) {
            .panels {
                grid-template-columns: 1fr;
                grid-template-rows: auto;
            }
            .main-upload-section { grid-column: 1; grid-row: auto; }
            .settings-column { grid-column: 1; grid-row: auto; }
            .main-gallery-section { grid-column: 1; grid-row: auto; }
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .panel h2 {
            font-size: 1.2rem;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-column {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* ===== Upload Zone ===== */
        .upload-zone {
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            cursor: pointer;
            margin-bottom: 15px;
        }

        .upload-zone:hover, .upload-zone.dragover {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
        }

        .upload-zone svg {
            width: 40px;
            height: 40px;
            margin-bottom: 10px;
            opacity: 0.5;
        }

        .upload-zone p {
            color: #888;
        }

        #file-input {
            display: none;
        }

        /* ===== Stats Bar ===== */
        .stats-bar {
            display: flex;
            gap: 25px;
            padding: 12px 0;
            color: #888;
            font-size: 0.9rem;
        }

        .stat {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .stat-value {
            color: #e0e0e0;
            font-weight: 600;
        }

        /* ===== Toolbar ===== */
        .toolbar {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 12px 16px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
            border: 1px solid rgba(255, 255, 255, 0.08);
        }

        .toolbar-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toolbar-right {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .selection-count {
            color: #888;
            font-size: 0.85rem;
        }

        /* ===== Filter Tabs ===== */
        .filter-tabs {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.2);
            padding: 3px;
            border-radius: 8px;
        }

        .filter-tab {
            padding: 6px 14px;
            border: none;
            background: transparent;
            color: #888;
            cursor: pointer;
            border-radius: 6px;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        .filter-tab:hover {
            color: #e0e0e0;
        }

        .filter-tab.active {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        /* ===== Buttons ===== */
        .btn {
            padding: 8px 14px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 500;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn:hover:not(:disabled) {
            transform: translateY(-1px);
        }

        .btn-success {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .btn-warning {
            background: rgba(255, 193, 7, 0.2);
            color: #ffc107;
            border: 1px solid rgba(255, 193, 7, 0.3);
        }

        .btn-danger {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
            border: 1px solid rgba(255, 71, 87, 0.3);
        }

        /* ===== Gallery Grid ===== */
        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .image-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.1);
            transition: transform 0.2s, border-color 0.2s;
            position: relative;
        }

        .image-card:hover {
            transform: translateY(-3px);
        }

        .image-card.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.3);
        }

        .image-card.disabled {
            opacity: 0.6;
        }

        .image-card.disabled .card-thumb::after {
            content: 'HIDDEN';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: #ff4757;
            padding: 6px 14px;
            border-radius: 16px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .card-thumb {
            position: relative;
            aspect-ratio: 4/3;
            overflow: hidden;
            cursor: pointer;
        }

        .card-thumb img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .status-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .status-enabled {
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
        }

        .status-disabled {
            background: rgba(255, 71, 87, 0.2);
            color: #ff4757;
        }

        .card-info {
            padding: 10px;
        }

        .card-filename {
            font-size: 0.8rem;
            color: #e0e0e0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 4px;
        }

        .card-meta {
            display: flex;
            justify-content: space-between;
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 8px;
        }

        .mat-color-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.8rem;
        }

        .mat-color-row label {
            color: #888;
        }

        .mat-color-picker {
            width: 36px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: transparent;
            padding: 0;
        }

        .mat-color-picker::-webkit-color-swatch-wrapper {
            padding: 2px;
        }

        .mat-color-picker::-webkit-color-swatch {
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .card-actions {
            display: flex;
            gap: 6px;
        }

        .card-actions button {
            flex: 1;
            padding: 6px;
            font-size: 0.75rem;
        }

        /* ===== Group Cards ===== */
        .group-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(123, 44, 191, 0.4);
            transition: transform 0.2s, border-color 0.2s;
            position: relative;
        }

        .group-card:hover {
            transform: translateY(-3px);
        }

        .group-mosaic {
            position: relative;
            aspect-ratio: 4/3;
            overflow: hidden;
            cursor: pointer;
            display: grid;
            gap: 2px;
            background: rgba(0, 0, 0, 0.3);
        }

        .group-mosaic.cols-2 { grid-template-columns: 1fr 1fr; }
        .group-mosaic.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
        .group-mosaic.cols-2x2 { grid-template-columns: 1fr 1fr; grid-template-rows: 1fr 1fr; }

        .group-mosaic img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .group-badge {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(123, 44, 191, 0.8);
            color: white;
            padding: 3px 10px;
            border-radius: 10px;
            font-size: 0.65rem;
            font-weight: 600;
            z-index: 5;
        }

        .btn-group {
            background: rgba(123, 44, 191, 0.2);
            color: #c084fc;
            border: 1px solid rgba(123, 44, 191, 0.4);
        }

        .btn-ungroup {
            background: rgba(255, 255, 255, 0.1);
            color: #aaa;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .btn-edit {
            background: rgba(0, 212, 255, 0.15);
            color: #00d4ff;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }

        .group-edit-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .group-edit-item:last-child {
            border-bottom: none;
        }

        .group-edit-thumb {
            width: 40px;
            height: 40px;
            border-radius: 4px;
            object-fit: cover;
            flex-shrink: 0;
        }

        .group-edit-controls {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
            min-width: 0;
        }

        .group-edit-controls input[type="range"] {
            flex: 1;
            min-width: 60px;
            accent-color: #00d4ff;
        }

        .scale-value {
            font-size: 0.7rem;
            color: #aaa;
            min-width: 32px;
            text-align: center;
        }

        .move-btn {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #ccc;
            width: 26px;
            height: 26px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            flex-shrink: 0;
        }

        .move-btn:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .move-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Group preview */
        .mat-preview .group-preview-images {
            display: flex;
            align-items: center;
            justify-content: space-evenly;
            width: 100%;
            height: 100%;
        }

        .mat-preview .group-preview-images img {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .mat-preview .group-preview-grid {
            display: grid;
            width: 100%;
            height: 100%;
            align-items: center;
            justify-items: center;
            justify-content: space-evenly;
            align-content: space-evenly;
        }

        .mat-preview .group-preview-grid img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        /* ===== Settings Panel ===== */
        .setting-group {
            margin-bottom: 18px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: #aaa;
        }

        .setting-group input[type="color"] {
            width: 100%;
            height: 42px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            background: transparent;
        }

        .setting-group input[type="number"],
        .setting-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            font-size: 0.95rem;
        }

        .setting-group input[type="number"]:focus,
        .setting-group select:focus {
            outline: none;
            border-color: #00d4ff;
        }

        .setting-group input[type="range"] {
            width: 100%;
            accent-color: #00d4ff;
        }

        .color-presets {
            display: flex;
            gap: 7px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        .color-preset {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.2s, border-color 0.2s;
        }

        .color-preset:hover {
            transform: scale(1.1);
        }

        .color-preset.active {
            border-color: #00d4ff;
        }

        .btn-apply {
            background: linear-gradient(90deg, #7b2cbf, #00d4ff);
            color: white;
            border: none;
            width: 100%;
            margin-top: 12px;
            font-weight: 600;
        }

        .toggle-group {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .toggle-group label {
            margin-bottom: 0;
        }

        .toggle {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            inset: 0;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 26px;
            transition: 0.3s;
        }

        .toggle-slider:before {
            content: "";
            position: absolute;
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: white;
            border-radius: 50%;
            transition: 0.3s;
        }

        .toggle input:checked + .toggle-slider {
            background: linear-gradient(90deg, #7b2cbf, #00d4ff);
        }

        .toggle input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }

        /* ===== Status Messages ===== */
        .status {
            padding: 10px 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            display: none;
        }

        .status.success {
            display: block;
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid rgba(0, 255, 136, 0.3);
            color: #00ff88;
        }

        .status.error {
            display: block;
            background: rgba(255, 71, 87, 0.1);
            border: 1px solid rgba(255, 71, 87, 0.3);
            color: #ff4757;
        }

        /* ===== Empty State ===== */
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .empty-state svg {
            width: 60px;
            height: 60px;
            margin-bottom: 12px;
            opacity: 0.3;
        }

        /* ===== TV Schedule Styles ===== */
        .tv-schedule-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .tv-schedule-item {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 10px;
            padding: 12px;
        }
        .tv-schedule-times {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
        }
        .tv-schedule-times input[type="time"] {
            flex: 1;
            padding: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #e0e0e0;
            font-size: 0.9rem;
        }
        .tv-schedule-times input[type="time"]:focus {
            outline: none;
            border-color: #00d4ff;
        }
        .tv-schedule-times span {
            color: #888;
            font-size: 0.8rem;
        }
        .tv-schedule-days {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        .day-checkbox {
            width: 32px;
            height: 32px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.2);
            color: #888;
            font-size: 0.7rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            user-select: none;
        }
        .day-checkbox.active {
            background: rgba(0, 212, 255, 0.2);
            border-color: rgba(0, 212, 255, 0.4);
            color: #00d4ff;
        }
        .tv-schedule-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .cec-unavailable {
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.2);
            border-radius: 8px;
            padding: 12px;
            font-size: 0.8rem;
            color: #ffc107;
            text-align: center;
        }

        /* ===== Upload Warning Modal ===== */
        .upload-modal-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }
        .upload-modal-overlay.active {
            display: flex;
        }
        .upload-modal {
            background: #1e2a3a;
            border-radius: 16px;
            padding: 24px;
            max-width: 680px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.5);
        }
        .upload-modal h3 {
            margin-bottom: 16px;
            color: #e0e0e0;
        }
        .upload-modal-file {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 12px;
            margin-bottom: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        .upload-modal-file input[type="checkbox"] {
            margin-top: 4px;
            flex-shrink: 0;
        }
        .upload-modal-file-info {
            flex: 1;
            min-width: 0;
        }
        .upload-modal-file-name {
            font-weight: 500;
            word-break: break-all;
        }
        .upload-modal-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-top: 4px;
            margin-right: 4px;
        }
        .badge-duplicate {
            background: rgba(255, 165, 0, 0.25);
            color: #ffb347;
        }
        .badge-small {
            background: rgba(255, 80, 80, 0.25);
            color: #ff7b7b;
        }
        .badge-ok {
            background: rgba(0, 200, 100, 0.2);
            color: #66d9a0;
        }
        .upload-modal-match {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 6px;
            font-size: 0.8rem;
            color: #aaa;
        }
        .upload-modal-match img {
            width: 40px;
            height: 40px;
            object-fit: cover;
            border-radius: 4px;
        }
        .upload-modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 16px;
        }
        .upload-modal-actions button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
        }
        .btn-upload-proceed {
            background: #00d4ff;
            color: #1a1a2e;
        }
        .btn-upload-proceed:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }
        .btn-upload-cancel {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
        }

        /* ===== Mobile Layout ===== */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 1.5rem;
            }

            .display-link {
                padding: 8px 16px;
                font-size: 0.85rem;
            }

            .panels {
                display: flex;
                flex-direction: column;
                gap: 12px;
            }

            .main-upload-section {
                order: 1;
            }

            .settings-column {
                order: 2;
            }

            .main-gallery-section {
                order: 3;
            }

            /* Upload zone: compact */
            .upload-zone {
                padding: 15px;
            }

            .upload-zone svg {
                width: 24px;
                height: 24px;
            }

            /* Preview: more compact */
            .mat-preview {
                aspect-ratio: 4/3;
            }

            .preview-controls {
                padding: 10px;
            }

            /* Gallery: horizontal thumbnail strip */
            .gallery-grid {
                display: flex !important;
                overflow-x: auto;
                gap: 8px;
                padding: 8px 0;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: thin;
            }

            .gallery-grid .image-card,
            .gallery-grid .group-card {
                flex: 0 0 auto;
                width: 72px;
                border-radius: 8px;
            }

            .gallery-grid .card-info {
                display: none;
            }

            .gallery-grid .card-thumb {
                aspect-ratio: 1;
                border-radius: 8px;
            }

            .gallery-grid .status-badge {
                display: none;
            }

            .gallery-grid .group-mosaic {
                aspect-ratio: 1;
                border-radius: 8px;
            }

            .gallery-grid .group-badge {
                font-size: 0.5rem;
                padding: 2px 5px;
            }

            /* Toolbar: compact */
            .toolbar {
                padding: 8px 10px;
                gap: 8px;
            }

            /* Settings: compact */
            .settings-column .panel {
                padding: 12px;
            }

            .settings-column .panel h2 {
                font-size: 1rem;
                margin-bottom: 12px;
            }

            /* Color presets: smaller on mobile */
            .color-presets {
                gap: 5px;
            }

            .color-preset {
                width: 24px;
                height: 24px;
            }

            header {
                margin-bottom: 15px;
            }
        }

        /* Select mode: highlight selected cards */
        body.select-mode .image-card.selected {
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.3);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="header-top">
                {% if is_admin %}
                <a href="/backup" class="header-link">Backup</a>
                {% endif %}
                <a href="/change-password" class="header-link">Password</a>
                {% if is_admin %}
                <a href="/admin/users" class="header-link">Users</a>
                {% endif %}
                <a href="/logout" class="header-link">Logout</a>
            </div>
            <h1>üñºÔ∏è Pi Photo Frame</h1>
            <p class="subtitle">Logged in as {{ username }}</p>
            <a href="/display" class="display-link" target="_blank">Open TV Display ‚Üí</a>
        </header>

        <!-- Preview Section -->
        <div class="preview-section" id="preview-section">
            <div class="mat-preview" id="mat-preview">
                <div id="preview-content"></div>
                <button class="preview-close-btn" onclick="closePreview()" title="Close">&times;</button>
            </div>
            <div class="preview-controls" id="preview-controls">
                <div class="preview-controls-header">
                    <h3 id="preview-controls-title">Group Controls</h3>
                    <div class="preview-controls-actions">
                        <button class="btn btn-refresh" onclick="autoMatchHeights()">Match Heights</button>
                        <button class="btn btn-refresh" onclick="refreshPreview()">Refresh Preview</button>
                    </div>
                </div>
                <div id="preview-controls-body"></div>
            </div>
        </div>

        <div class="panels">
            <!-- Upload Section -->
            <div class="panel main-upload-section">
                <div id="status" class="status"></div>

                <div class="upload-zone" id="upload-zone">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <p>Drag & drop images here or click to browse</p>
                    <p style="font-size: 0.8rem; margin-top: 8px;">Supports: JPG, PNG, GIF, WebP</p>
                </div>
                <input type="file" id="file-input" multiple accept="image/*">

                <!-- Stats -->
                <div class="stats-bar">
                    <div class="stat">
                        <span>Total:</span>
                        <span class="stat-value" id="total-count">0</span>
                    </div>
                    <div class="stat">
                        <span>Visible:</span>
                        <span class="stat-value" id="enabled-count">0</span>
                    </div>
                    <div class="stat">
                        <span>Hidden:</span>
                        <span class="stat-value" id="disabled-count">0</span>
                    </div>
                </div>
            </div>

            <!-- Gallery Section -->
            <div class="main-gallery-section">
                <!-- Toolbar -->
                <div class="toolbar">
                    <div class="toolbar-left">
                        <button class="btn btn-edit" id="toggle-select-mode" onclick="toggleSelectMode()">Select</button>
                        <span class="selection-count" id="selection-count-wrapper" style="display:none;"><span id="selected-count">0</span> selected</span>
                        <div class="filter-tabs">
                            <button class="filter-tab active" data-filter="all">All</button>
                            <button class="filter-tab" data-filter="enabled">Visible</button>
                            <button class="filter-tab" data-filter="disabled">Hidden</button>
                        </div>
                    </div>
                    <div class="toolbar-right" style="display:none;">
                        <button class="btn btn-group" id="bulk-group" disabled>üìê Group</button>
                        <button class="btn btn-success" id="bulk-enable" disabled>‚úì Show</button>
                        <button class="btn btn-warning" id="bulk-disable" disabled>‚äò Hide</button>
                        <button class="btn btn-danger" id="bulk-delete" disabled>üóë Delete</button>
                    </div>
                </div>

                <!-- Gallery Grid -->
                <div class="gallery-grid" id="gallery-grid"></div>

                <div class="empty-state" id="empty-state" style="display: none;">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                    </svg>
                    <p>No photos yet</p>
                    <p style="font-size: 0.9rem;">Upload some photos to get started</p>
                </div>
            </div>

            <!-- Settings Sidebar -->
            <div class="settings-column">
                <!-- Mat Settings -->
                <div class="panel">
                    <h2>üé® Mat Settings</h2>

                    <div class="setting-group">
                        <label>Default Mat Color</label>
                        <input type="hidden" id="mat-color" value="{{ settings.mat_color }}">
                        <div class="color-presets">
                            <div class="color-preset" style="background: #ffffff; border: 1px solid rgba(255,255,255,0.2);" data-color="#ffffff" title="White"></div>
                            <div class="color-preset" style="background: #faf9f6;" data-color="#faf9f6" title="Soft White"></div>
                            <div class="color-preset" style="background: #f5f0e6;" data-color="#f5f0e6" title="Cream"></div>
                            <div class="color-preset" style="background: #fffff0;" data-color="#fffff0" title="Ivory"></div>
                            <div class="color-preset" style="background: #faf0e6;" data-color="#faf0e6" title="Linen"></div>
                            <div class="color-preset" style="background: #f0ead6;" data-color="#f0ead6" title="Eggshell"></div>
                            <div class="color-preset" style="background: #faebd7;" data-color="#faebd7" title="Antique White"></div>
                            <div class="color-preset" style="background: #e8dfd5;" data-color="#e8dfd5" title="Sand"></div>
                            <div class="color-preset" style="background: #e0d8cf;" data-color="#e0d8cf" title="Oyster"></div>
                            <div class="color-preset" style="background: #d6cec5;" data-color="#d6cec5" title="Pebble"></div>
                            <div class="color-preset" style="background: #2c2c2c;" data-color="#2c2c2c" title="Charcoal"></div>
                            <div class="color-preset" style="background: #1a1a2e;" data-color="#1a1a2e" title="Dark Navy"></div>
                            <div class="color-preset" style="background: #3d0c02;" data-color="#3d0c02" title="Dark Burgundy"></div>
                            <div class="color-preset" style="background: #1b3a2d;" data-color="#1b3a2d" title="Forest Green"></div>
                            <div class="color-preset" style="background: #4a3728;" data-color="#4a3728" title="Espresso"></div>
                            <div class="color-preset" style="background: #8b0000;" data-color="#8b0000" title="Dark Red"></div>
                            <div class="color-preset" style="background: #003366;" data-color="#003366" title="Navy Blue"></div>
                            <div class="color-preset" style="background: #2e5339;" data-color="#2e5339" title="Hunter Green"></div>
                            <div class="color-preset" style="background: #4b0082;" data-color="#4b0082" title="Indigo"></div>
                            <div class="color-preset" style="background: #704214;" data-color="#704214" title="Sepia"></div>
                            <div class="color-preset" style="background: #b8860b;" data-color="#b8860b" title="Dark Gold"></div>
                            <div class="color-preset" style="background: #556b2f;" data-color="#556b2f" title="Olive"></div>
                            <div class="color-preset" style="background: #800020;" data-color="#800020" title="Burgundy"></div>
                            <div class="color-preset" style="background: #708090;" data-color="#708090" title="Slate Gray"></div>
                            <div class="color-preset" style="background: #c4a882;" data-color="#c4a882" title="Tan"></div>
                            <div class="color-preset" style="background: #d4a574;" data-color="#d4a574" title="Camel"></div>
                            <div class="color-preset" style="background: #c08081;" data-color="#c08081" title="Dusty Rose"></div>
                            <div class="color-preset" style="background: #7b9ea8;" data-color="#7b9ea8" title="Steel Blue"></div>
                            <div class="color-preset" style="background: #8fbc8f;" data-color="#8fbc8f" title="Sage"></div>
                            <div class="color-preset" style="background: #a9a9a9;" data-color="#a9a9a9" title="Dark Gray"></div>
                        </div>
                    </div>

                    <div class="setting-group">
                        <label>Mat Finish</label>
                        <select id="mat-finish">
                            <option value="flat" {% if settings.mat_finish == 'flat' %}selected{% endif %}>Flat</option>
                            <option value="linen" {% if settings.mat_finish == 'linen' %}selected{% endif %}>Linen</option>
                            <option value="suede" {% if settings.mat_finish == 'suede' %}selected{% endif %}>Suede</option>
                            <option value="silk" {% if settings.mat_finish == 'silk' %}selected{% endif %}>Silk</option>
                        </select>
                    </div>

                    <div class="setting-group">
                        <label>Border Effect</label>
                        <select id="border-effect">
                            <option value="bevel" {% if settings.border_effect == 'bevel' %}selected{% endif %}>Bevel</option>
                            <option value="shadow" {% if settings.border_effect == 'shadow' %}selected{% endif %}>Shadow</option>
                        </select>
                    </div>

                    <div class="setting-group">
                        <label><span id="effect-size-label">{{ 'Shadow' if settings.border_effect == 'shadow' else 'Bevel' }}</span> Size <span id="bevel-value">{{ settings.bevel_width }}px</span></label>
                        <input type="range" id="bevel-width" min="0" max="16" value="{{ settings.bevel_width }}" step="1">
                    </div>

                    <button class="btn btn-apply" id="apply-mat-settings">Apply</button>

                    <p style="font-size: 0.75rem; color: #666; margin-top: 8px;">
                        Select an image to customize individually.
                    </p>
                </div>

                <!-- Slideshow Settings -->
                <div class="panel">
                    <h2>üì∫ Slideshow Settings</h2>

                    <div class="setting-group">
                        <label>Slideshow Interval (seconds)</label>
                        <input type="number" id="slideshow-interval" min="3" max="300" value="{{ settings.slideshow_interval }}">
                    </div>

                    <div class="setting-group">
                        <label>Transition Duration (seconds)</label>
                        <input type="number" id="transition-duration" min="0" max="5" step="0.5" value="{{ settings.transition_duration }}">
                    </div>

                    <div class="setting-group">
                        <label>Image Fit</label>
                        <select id="fit-mode">
                            <option value="contain" {% if settings.fit_mode == 'contain' %}selected{% endif %}>Contain (show full image)</option>
                            <option value="cover" {% if settings.fit_mode == 'cover' %}selected{% endif %}>Cover (fill screen, may crop)</option>
                        </select>
                    </div>

                    <div class="toggle-group">
                        <label>Shuffle Order</label>
                        <label class="toggle">
                            <input type="checkbox" id="shuffle" {% if settings.shuffle %}checked{% endif %}>
                            <span class="toggle-slider"></span>
                        </label>
                    </div>

                    <div class="setting-group">
                        <label>Target Screen Ratio</label>
                        <select id="target-aspect-ratio">
                            <option value="16:9" {% if settings.target_aspect_ratio == '16:9' %}selected{% endif %}>16:9 (4K TV)</option>
                            <option value="21:9" {% if settings.target_aspect_ratio == '21:9' %}selected{% endif %}>21:9 (Ultrawide)</option>
                            <option value="4:3" {% if settings.target_aspect_ratio == '4:3' %}selected{% endif %}>4:3 (Standard)</option>
                            <option value="1:1" {% if settings.target_aspect_ratio == '1:1' %}selected{% endif %}>1:1 (Square)</option>
                        </select>
                    </div>

                    <p style="font-size: 0.75rem; color: #666; text-align: center;">
                        Slideshow settings are saved automatically.
                    </p>
                </div>

                <!-- TV Schedule Settings -->
                <div class="panel" id="tv-schedule-panel">
                    <h2>TV Power Schedule</h2>

                    <div id="cec-unavailable-msg" class="cec-unavailable" style="display:none;">
                        CEC control is not available. Install cec-utils and ensure the
                        HDMI-CEC device is accessible in Docker.
                    </div>

                    <div id="cec-controls" style="display:none;">
                        <div class="tv-schedule-list" id="tv-schedule-list"></div>

                        <div style="margin-top: 12px; display: flex; gap: 8px;">
                            <button class="btn btn-refresh" onclick="addTvSchedule()" style="flex:1;">+ Add Schedule</button>
                            <button class="btn btn-refresh" onclick="testCec('on')" title="Turn TV on now">Test On</button>
                            <button class="btn btn-refresh" onclick="testCec('standby')" title="Turn TV off now">Test Off</button>
                        </div>

                        <p style="font-size: 0.75rem; color: #666; text-align: center; margin-top: 10px;">
                            Schedules are saved automatically.
                        </p>
                    </div>
                </div>

                {% if is_admin and password_changed %}
                <!-- Network Info -->
                <div class="panel" id="network-info-panel">
                    <h2>Network</h2>
                    <div id="network-info-content" style="font-size: 0.85rem; color: #aaa;">
                        Loading...
                    </div>
                </div>
                {% endif %}
            </div>
        </div>
    </div>

    <script>
        // ===== CSRF Token =====
        const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');

        // Wrap fetch to automatically include CSRF token
        const _origFetch = window.fetch;
        window.fetch = function(url, options = {}) {
            if (options.method && options.method !== 'GET') {
                options.headers = options.headers || {};
                if (options.headers instanceof Headers) {
                    options.headers.set('X-CSRFToken', csrfToken);
                } else {
                    options.headers['X-CSRFToken'] = csrfToken;
                }
            }
            return _origFetch.call(this, url, options);
        };

        // ===== DOM Elements =====
        const uploadZone = document.getElementById('upload-zone');
        const fileInput = document.getElementById('file-input');
        const galleryGrid = document.getElementById('gallery-grid');
        const emptyState = document.getElementById('empty-state');
        const statusEl = document.getElementById('status');
        const previewSection = document.getElementById('preview-section');
        const matPreview = document.getElementById('mat-preview');
        const previewContent = document.getElementById('preview-content');
        const previewControls = document.getElementById('preview-controls');
        const previewControlsBody = document.getElementById('preview-controls-body');
        const previewControlsTitle = document.getElementById('preview-controls-title');

        // Color presets shared between default and per-image controls
        const COLOR_PRESETS = [
            // Light neutrals
            {color: '#ffffff', title: 'White'}, {color: '#faf9f6', title: 'Soft White'},
            {color: '#f5f0e6', title: 'Cream'}, {color: '#fffff0', title: 'Ivory'},
            {color: '#faf0e6', title: 'Linen'}, {color: '#f0ead6', title: 'Eggshell'},
            {color: '#faebd7', title: 'Antique White'}, {color: '#e8dfd5', title: 'Sand'},
            {color: '#e0d8cf', title: 'Oyster'}, {color: '#d6cec5', title: 'Pebble'},
            // Darks and rich colors
            {color: '#2c2c2c', title: 'Charcoal'}, {color: '#1a1a2e', title: 'Dark Navy'},
            {color: '#3d0c02', title: 'Dark Burgundy'}, {color: '#1b3a2d', title: 'Forest Green'},
            {color: '#4a3728', title: 'Espresso'}, {color: '#8b0000', title: 'Dark Red'},
            {color: '#003366', title: 'Navy Blue'}, {color: '#2e5339', title: 'Hunter Green'},
            {color: '#4b0082', title: 'Indigo'}, {color: '#704214', title: 'Sepia'},
            // Mid-tones
            {color: '#b8860b', title: 'Dark Gold'}, {color: '#556b2f', title: 'Olive'},
            {color: '#800020', title: 'Burgundy'}, {color: '#708090', title: 'Slate Gray'},
            {color: '#c4a882', title: 'Tan'}, {color: '#d4a574', title: 'Camel'},
            {color: '#c08081', title: 'Dusty Rose'}, {color: '#7b9ea8', title: 'Steel Blue'},
            {color: '#8fbc8f', title: 'Sage'}, {color: '#a9a9a9', title: 'Dark Gray'},
        ];

        // Settings elements
        const matColorInput = document.getElementById('mat-color');
        const matFinishSelect = document.getElementById('mat-finish');
        const borderEffectSelect = document.getElementById('border-effect');
        const bevelWidthInput = document.getElementById('bevel-width');
        const bevelValueLabel = document.getElementById('bevel-value');
        const effectSizeLabel = document.getElementById('effect-size-label');
        const slideshowIntervalInput = document.getElementById('slideshow-interval');
        const transitionDurationInput = document.getElementById('transition-duration');
        const fitModeSelect = document.getElementById('fit-mode');
        const targetAspectRatioSelect = document.getElementById('target-aspect-ratio');
        const shuffleCheckbox = document.getElementById('shuffle');
        const colorPresets = document.querySelectorAll('.settings-column .color-preset');

        // ===== State =====
        let images = [];
        let groups = {};  // group_id -> {images: [...], mat_color, created_at}
        let selectedImages = new Set();
        let currentFilter = 'all';
        let previewFilename = null;
        let previewGroupId = null;

        // ===== Initialize =====
        updatePreviewAspectRatio();
        loadGallery();

        // ===== Upload Handling =====
        uploadZone.addEventListener('click', () => fileInput.click());

        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            handleFiles(e.dataTransfer.files);
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(e.target.files);
        });

        // Pending files for the two-phase upload flow
        let pendingUploadFiles = [];

        async function handleFiles(files) {
            pendingUploadFiles = Array.from(files);

            // Phase 1: Check for duplicates and dimensions
            showStatus('Checking for duplicates...', 'success');
            const formData = new FormData();
            for (const file of pendingUploadFiles) {
                formData.append('files', file);
            }

            let checkResults = null;
            try {
                const resp = await fetch('/api/check-duplicates', {
                    method: 'POST',
                    body: formData
                });
                checkResults = await resp.json();
            } catch (err) {
                // If check fails, fall through to direct upload
            }

            // Determine if any warnings exist
            const MIN_WIDTH = 1280, MIN_HEIGHT = 720;
            let hasWarnings = false;

            if (checkResults && checkResults.results) {
                for (const fname of Object.keys(checkResults.results)) {
                    const r = checkResults.results[fname];
                    if (r.matches && r.matches.length > 0) hasWarnings = true;
                    if (r.width < MIN_WIDTH || r.height < MIN_HEIGHT) hasWarnings = true;
                }
            }

            if (!hasWarnings || !checkResults) {
                // No warnings ‚Äî upload directly
                await doUpload(pendingUploadFiles);
                return;
            }

            // Phase 2: Show warning modal
            showUploadModal(checkResults.results);
        }

        function showUploadModal(results) {
            const MIN_WIDTH = 1280, MIN_HEIGHT = 720;
            const body = document.getElementById('upload-modal-body');
            let html = '';

            for (const file of pendingUploadFiles) {
                const r = results[file.name] || {};
                const matches = r.matches || [];
                const isSmall = (r.width && r.height) && (r.width < MIN_WIDTH || r.height < MIN_HEIGHT);
                const hasDupes = matches.length > 0;
                const hasIssue = isSmall || hasDupes;

                html += `<div class="upload-modal-file">
                    <input type="checkbox" data-filename="${escAttr(file.name)}" ${hasIssue ? '' : 'checked'}>
                    <div class="upload-modal-file-info">
                        <div class="upload-modal-file-name">${escAttr(file.name)}</div>`;

                if (isSmall) {
                    html += `<span class="upload-modal-badge badge-small">Low res: ${r.width}&times;${r.height}</span>`;
                }
                if (hasDupes) {
                    for (const m of matches) {
                        const similarity = Math.max(0, 100 - Math.round(m.distance * 100 / 64));
                        html += `<div class="upload-modal-match">
                            <img src="/uploads/${escAttr(m.filename)}" alt="match">
                            <span>Similar to <strong>${cleanFilename(m.filename)}</strong> (${similarity}% match)</span>
                        </div>`;
                    }
                    html += `<span class="upload-modal-badge badge-duplicate">Possible duplicate</span>`;
                }
                if (!hasIssue) {
                    html += `<span class="upload-modal-badge badge-ok">OK</span>`;
                }

                if (r.width && r.height) {
                    html += `<div style="font-size:0.75rem;color:#888;margin-top:4px;">${r.width}&times;${r.height}px</div>`;
                }

                html += `</div></div>`;
            }

            body.innerHTML = html;
            document.getElementById('upload-modal-overlay').classList.add('active');
            statusEl.className = 'status';
        }

        function cancelUploadModal() {
            document.getElementById('upload-modal-overlay').classList.remove('active');
            pendingUploadFiles = [];
            fileInput.value = '';
        }

        async function proceedUpload() {
            const checkboxes = document.querySelectorAll('#upload-modal-body input[type="checkbox"]');
            const selectedNames = new Set();
            checkboxes.forEach(cb => {
                if (cb.checked) selectedNames.add(cb.dataset.filename);
            });

            const filesToUpload = pendingUploadFiles.filter(f => selectedNames.has(f.name));
            document.getElementById('upload-modal-overlay').classList.remove('active');

            if (filesToUpload.length === 0) {
                showStatus('No files selected', 'error');
                pendingUploadFiles = [];
                fileInput.value = '';
                return;
            }

            await doUpload(filesToUpload);
        }

        async function doUpload(files) {
            const formData = new FormData();
            for (const file of files) {
                formData.append('files', file);
            }

            showStatus('Uploading...', 'success');

            try {
                const response = await fetch('/api/upload', {
                    method: 'POST',
                    body: formData
                });
                const data = await response.json();

                if (data.uploaded.length > 0) {
                    showStatus(`Uploaded ${data.uploaded.length} image(s)`, 'success');
                    loadGallery();
                }
                if (data.errors.length > 0) {
                    showStatus(data.errors.join(', '), 'error');
                }
            } catch (err) {
                showStatus('Upload failed: ' + err.message, 'error');
            }

            pendingUploadFiles = [];
            fileInput.value = '';
        }

        // ===== Gallery Loading =====
        async function loadGallery() {
            try {
                const response = await fetch('/api/gallery');
                const data = await response.json();
                images = data.images;
                groups = data.groups || {};
                renderGallery();
                updateStats();
            } catch (err) {
                showStatus('Failed to load gallery', 'error');
            }
        }

        function renderGallery() {
            const grid = galleryGrid;

            // Build set of grouped filenames
            const groupedFilenames = new Set();
            for (const group of Object.values(groups)) {
                (group.images || []).forEach(f => groupedFilenames.add(f));
            }

            let filtered = images;
            if (currentFilter === 'enabled') {
                filtered = images.filter(img => img.enabled);
            } else if (currentFilter === 'disabled') {
                filtered = images.filter(img => !img.enabled);
            }

            // Separate ungrouped images from grouped, sorted by upload time (newest first)
            const ungrouped = filtered.filter(img => !groupedFilenames.has(img.filename));
            ungrouped.sort((a, b) => (b.uploaded_at || '').localeCompare(a.uploaded_at || ''));

            if (images.length === 0 && Object.keys(groups).length === 0) {
                grid.style.display = 'none';
                emptyState.style.display = 'block';
                return;
            }

            grid.style.display = 'grid';
            emptyState.style.display = 'none';

            // Render group cards first, then ungrouped images
            let html = '';

            // Group cards (only show if filter is 'all' or 'enabled' since groups are visible)
            if (currentFilter !== 'disabled') {
                for (const [groupId, group] of Object.entries(groups)) {
                    const groupImages = (group.images || []).map(f => images.find(i => i.filename === f)).filter(Boolean);
                    if (groupImages.length < 2) continue;

                    const count = groupImages.length;
                    const mosaicClass = count === 2 ? 'cols-2' : count === 3 ? 'cols-3' : 'cols-2x2';
                    const displayImages = groupImages.slice(0, 4);

                    html += `
                        <div class="group-card" data-group-id="${groupId}">
                            <div class="group-mosaic ${mosaicClass}" onclick="openGroupPreview('${groupId}')">
                                <span class="group-badge">${count} images</span>
                                ${displayImages.map(img => `<img src="/uploads/${escAttr(img.filename)}" alt="${escAttr(img.filename)}" loading="lazy">`).join('')}
                            </div>
                            <div class="card-info">
                                <div class="card-filename">Group (${count} images)</div>
                                <div class="mat-color-row">
                                    <label>Mat:</label>
                                    <input type="color"
                                           class="mat-color-picker"
                                           value="${group.mat_color || matColorInput.value}"
                                           onchange="updateGroupMatColor('${groupId}', this.value)">
                                </div>
                                <div class="card-actions">
                                    <button class="btn btn-edit" onclick="openGroupPreview('${groupId}')">Edit</button>
                                    <button class="btn btn-ungroup" onclick="ungroupGroup('${groupId}')">Ungroup</button>
                                    <button class="btn btn-danger" onclick="deleteGroup('${groupId}')">üóë</button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            }

            // Ungrouped image cards
            html += ungrouped.map(img => `
                <div class="image-card ${img.enabled ? '' : 'disabled'} ${selectedImages.has(img.filename) ? 'selected' : ''}"
                     data-filename="${escAttr(img.filename)}">
                    <div class="card-thumb" onclick="handleCardClick('${escAttr(img.filename)}')">
                        <span class="status-badge ${img.enabled ? 'status-enabled' : 'status-disabled'}">
                            ${img.enabled ? 'Visible' : 'Hidden'}
                        </span>
                        <img src="/uploads/${escAttr(img.filename)}" alt="${escAttr(img.filename)}" loading="lazy">
                    </div>
                    <div class="card-info">
                        <div class="card-filename" title="${escAttr(img.filename)}">${cleanFilename(escAttr(img.filename))}</div>
                        <div class="card-meta">
                            <span>${formatSize(img.size)}</span>
                            <span>${img.uploaded_by || 'Unknown'}</span>
                        </div>
                        <div class="mat-color-row">
                            <label>Mat:</label>
                            <input type="color"
                                   class="mat-color-picker"
                                   value="${img.mat_color || matColorInput.value}"
                                   data-filename="${escAttr(img.filename)}"
                                   onchange="updateMatColor('${escAttr(img.filename)}', this.value)">
                        </div>
                        <div class="card-actions">
                            <button class="btn ${img.enabled ? 'btn-warning' : 'btn-success'}"
                                    onclick="toggleImage('${escAttr(img.filename)}', ${!img.enabled})">
                                ${img.enabled ? '‚äò Hide' : '‚úì Show'}
                            </button>
                            <button class="btn btn-danger" onclick="deleteImage('${escAttr(img.filename)}')">üóë</button>
                        </div>
                    </div>
                </div>
            `).join('');

            grid.innerHTML = html;
            updateSelectionUI();
        }

        // ===== Preview =====
        function openPreview(filename) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;

            previewFilename = filename;
            previewGroupId = null;

            previewControls.classList.add('active');
            previewSection.classList.add('has-controls');
            previewSection.classList.add('active');

            renderSinglePreviewImage(filename);
            renderSingleControls(filename);
        }

        function renderSinglePreviewImage(filename) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;

            const matColor = img.mat_color || matColorInput.value;
            const effectSize = img.bevel_width ?? parseInt(bevelWidthInput.value);
            const borderEffect = img.border_effect || borderEffectSelect.value;
            const finish = img.mat_finish || matFinishSelect.value;
            const scale = img.scale || 1.0;

            matPreview.style.backgroundColor = matColor;
            matPreview.classList.remove('mat-linen', 'mat-suede', 'mat-silk');
            if (finish !== 'flat') matPreview.classList.add('mat-' + finish);

            // Compute pixel dimensions ‚Äî photo+effect must fit in frame
            const containerW = previewContent.clientWidth;
            const containerH = previewContent.clientHeight;
            const effectSpace = borderEffect === 'shadow' ? Math.round(effectSize * 2) : effectSize;
            const effect2 = (effectSpace > 0 ? effectSpace : 0) * 2;

            // Photo ‚â§ 95% of container; photo+effect ‚â§ container
            const maxPhotoW = Math.min(containerW * 0.95, containerW - effect2);
            const maxPhotoH = Math.min(containerH * 0.95, containerH - effect2);

            // At scale=1 use 90%-effect as base, scale adjusts, hard-capped at max
            const baseW = Math.min(containerW * 0.90 - effect2, maxPhotoW);
            const baseH = Math.min(containerH * 0.90 - effect2, maxPhotoH);
            const scaledW = Math.max(1, Math.min(baseW * scale, maxPhotoW));
            const scaledH = Math.max(1, Math.min(baseH * scale, maxPhotoH));

            const rawRatio = (img.width && img.height) ? img.width / img.height : 4 / 3;
            const crop = img.crop;
            const imgRatio = crop ? (rawRatio * crop.w / crop.h) : rawRatio;
            let displayW, displayH;
            if (imgRatio > scaledW / scaledH) {
                displayW = scaledW;
                displayH = scaledW / imgRatio;
            } else {
                displayH = scaledH;
                displayW = scaledH * imgRatio;
            }

            let imgHtml;
            if (crop) {
                const dW = Math.round(displayW);
                const dH = Math.round(displayH);
                const fullW = Math.round(dW / crop.w);
                const fullH = Math.round(dH / crop.h);
                const offsetX = Math.round(-crop.x * fullW);
                const offsetY = Math.round(-crop.y * fullH);
                imgHtml = `<div style="width:${dW}px;height:${dH}px;overflow:hidden;line-height:0;">` +
                          `<img src="/uploads/${filename}" alt="${filename}" style="width:${fullW}px;height:${fullH}px;margin-left:${offsetX}px;margin-top:${offsetY}px;display:block;max-width:none;max-height:none;">` +
                          `</div>`;
            } else {
                imgHtml = `<img src="/uploads/${filename}" alt="${filename}" style="width:${Math.round(displayW)}px;height:${Math.round(displayH)}px;object-fit:contain;">`;
            }
            previewContent.innerHTML = makeEffectHtml(imgHtml, effectSize, matColor, borderEffect);
        }

        function renderSingleControls(filename) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;

            const scale = img.scale || 1.0;
            previewControlsTitle.textContent = cleanFilename(filename);
            document.querySelector('.preview-controls-actions').style.display = 'none';
            const currentFinish = img.mat_finish || '';
            const currentBevel = img.bevel_width ?? '';
            const currentBorderEffect = img.border_effect || '';
            const effectLabel = (currentBorderEffect || borderEffectSelect.value) === 'shadow' ? 'Shadow' : 'Bevel';

            const currentMatColor = img.mat_color || matColorInput.value;

            previewControlsBody.innerHTML = `
                <div class="group-edit-item">
                    <img class="group-edit-thumb" src="/uploads/${filename}" alt="${filename}">
                    <div class="group-edit-controls">
                        <input type="range" min="0.25" max="3" step="0.05"
                               value="${scale}"
                               oninput="updateSingleScalePreview('${filename}', this.value); this.nextElementSibling.textContent = parseFloat(this.value).toFixed(2) + 'x'"
                               onchange="updateSingleScale('${filename}', this.value)">
                        <span class="scale-value">${parseFloat(scale).toFixed(2)}x</span>
                    </div>
                </div>
                <div class="group-edit-item" style="flex-direction:column;gap:8px;">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">Mat Color:</label>
                        <button style="font-size:0.7rem;padding:2px 6px;border:1px solid rgba(255,255,255,0.1);border-radius:4px;background:rgba(0,0,0,0.3);color:#aaa;cursor:pointer;"
                                onclick="updateMatColor('${escAttr(filename)}', null); renderSinglePreviewImage('${escAttr(filename)}'); renderSingleControls('${escAttr(filename)}')">Reset</button>
                    </div>
                    <div class="color-presets" style="margin-top:0;">
                        ${COLOR_PRESETS.map(p => `<div class="color-preset${currentMatColor === p.color ? ' active' : ''}" style="background:${p.color};width:22px;height:22px;${p.color === '#ffffff' ? 'border:1px solid rgba(255,255,255,0.2);' : ''}" title="${p.title}" onclick="updateMatColor('${escAttr(filename)}','${p.color}'); renderSingleControls('${escAttr(filename)}')"></div>`).join('')}
                    </div>
                </div>
                <div class="group-edit-item" style="flex-wrap:wrap;gap:12px;">
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">Finish:</label>
                        <select style="flex:1;padding:6px;border:1px solid rgba(255,255,255,0.1);border-radius:6px;background:rgba(0,0,0,0.3);color:#e0e0e0;font-size:0.8rem;"
                                onchange="updateImageField('${escAttr(filename)}','mat_finish',this.value||null)">
                            <option value="" ${!currentFinish ? 'selected' : ''}>Default</option>
                            <option value="flat" ${currentFinish==='flat' ? 'selected' : ''}>Flat</option>
                            <option value="linen" ${currentFinish==='linen' ? 'selected' : ''}>Linen</option>
                            <option value="suede" ${currentFinish==='suede' ? 'selected' : ''}>Suede</option>
                            <option value="silk" ${currentFinish==='silk' ? 'selected' : ''}>Silk</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">Effect:</label>
                        <select style="flex:1;padding:6px;border:1px solid rgba(255,255,255,0.1);border-radius:6px;background:rgba(0,0,0,0.3);color:#e0e0e0;font-size:0.8rem;"
                                onchange="updateImageField('${escAttr(filename)}','border_effect',this.value||null); renderSingleControls('${escAttr(filename)}')">
                            <option value="" ${!currentBorderEffect ? 'selected' : ''}>Default</option>
                            <option value="bevel" ${currentBorderEffect==='bevel' ? 'selected' : ''}>Bevel</option>
                            <option value="shadow" ${currentBorderEffect==='shadow' ? 'selected' : ''}>Shadow</option>
                        </select>
                    </div>
                </div>
                <div class="group-edit-item" style="flex-wrap:wrap;gap:12px;">
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">${effectLabel}: <span id="single-bevel-val">${currentBevel !== '' ? currentBevel + 'px' : parseInt(bevelWidthInput.value) + 'px'}</span></label>
                        <input type="range" min="0" max="16" step="1" value="${currentBevel !== '' ? currentBevel : parseInt(bevelWidthInput.value)}"
                               style="flex:1;accent-color:#00d4ff;"
                               oninput="this.previousElementSibling.querySelector('span').textContent = this.value + 'px'; previewSingleBevel('${escAttr(filename)}', this.value)"
                               onchange="updateImageField('${escAttr(filename)}','bevel_width',parseInt(this.value))">
                    </div>
                </div>
                <div class="group-edit-item" style="gap:8px;">
                    <button class="btn btn-edit" onclick="enterCropMode('${escAttr(filename)}')">Crop</button>
                    <button class="btn btn-warning" onclick="clearCrop('${escAttr(filename)}')" ${!img.crop ? 'disabled style="opacity:0.5"' : ''}>Clear Crop</button>
                </div>
            `;
        }

        // ===== Crop Mode =====
        let cropState = null; // {filename, x, y, w, h, imgRect}

        function enterCropMode(filename) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;

            const existing = img.crop || {x: 0, y: 0, w: 1, h: 1};
            cropState = { filename, x: existing.x, y: existing.y, w: existing.w, h: existing.h };

            // Show uncropped image in preview
            matPreview.style.backgroundColor = '#111';
            matPreview.classList.remove('mat-linen', 'mat-suede', 'mat-silk');

            const containerW = previewContent.clientWidth;
            const containerH = previewContent.clientHeight;
            const imgRatio = (img.width || 1) / (img.height || 1);

            let dispW, dispH;
            if (imgRatio > containerW / containerH) {
                dispW = containerW * 0.92;
                dispH = dispW / imgRatio;
            } else {
                dispH = containerH * 0.92;
                dispW = dispH * imgRatio;
            }
            const offsetX = (containerW - dispW) / 2;
            const offsetY = (containerH - dispH) / 2;

            // Store image rect for coordinate conversion
            cropState.imgRect = {x: offsetX, y: offsetY, w: dispW, h: dispH};

            previewContent.style.position = 'relative';
            previewContent.innerHTML = `
                <img id="crop-image" src="/uploads/${filename}"
                     style="position:absolute;left:${offsetX}px;top:${offsetY}px;width:${dispW}px;height:${dispH}px;user-select:none;pointer-events:none;">
                <div class="crop-overlay" id="crop-overlay"></div>
                <div class="crop-selection" id="crop-selection">
                    <div class="crop-handle nw" data-handle="nw"></div>
                    <div class="crop-handle ne" data-handle="ne"></div>
                    <div class="crop-handle sw" data-handle="sw"></div>
                    <div class="crop-handle se" data-handle="se"></div>
                    <div class="crop-handle n" data-handle="n"></div>
                    <div class="crop-handle s" data-handle="s"></div>
                    <div class="crop-handle e" data-handle="e"></div>
                    <div class="crop-handle w" data-handle="w"></div>
                </div>
                <div class="crop-toolbar">
                    <button class="btn btn-success" onclick="applyCrop()">Apply</button>
                    <button class="btn btn-warning" onclick="cancelCrop()">Cancel</button>
                </div>
            `;

            updateCropSelection();
            initCropHandlers();
        }

        function updateCropSelection() {
            if (!cropState) return;
            const sel = document.getElementById('crop-selection');
            if (!sel) return;
            const r = cropState.imgRect;
            sel.style.left   = (r.x + cropState.x * r.w) + 'px';
            sel.style.top    = (r.y + cropState.y * r.h) + 'px';
            sel.style.width  = (cropState.w * r.w) + 'px';
            sel.style.height = (cropState.h * r.h) + 'px';
        }

        function initCropHandlers() {
            const overlay = document.getElementById('crop-overlay');
            const sel = document.getElementById('crop-selection');
            if (!overlay || !sel) return;

            let dragMode = null; // 'move' or handle name
            let startX, startY, startCrop;

            function getPointer(e) {
                const t = e.touches ? e.touches[0] : e;
                const rect = previewContent.getBoundingClientRect();
                return {x: t.clientX - rect.left, y: t.clientY - rect.top};
            }

            function onStart(e) {
                e.preventDefault();
                const target = e.target;
                const handle = target.dataset ? target.dataset.handle : null;
                if (handle) {
                    dragMode = handle;
                } else if (target === sel || sel.contains(target)) {
                    dragMode = 'move';
                } else {
                    return;
                }
                const p = getPointer(e);
                startX = p.x;
                startY = p.y;
                startCrop = {x: cropState.x, y: cropState.y, w: cropState.w, h: cropState.h};
            }

            function onMove(e) {
                if (!dragMode) return;
                e.preventDefault();
                const p = getPointer(e);
                const r = cropState.imgRect;
                const dx = (p.x - startX) / r.w;
                const dy = (p.y - startY) / r.h;
                const minSize = 0.05;

                if (dragMode === 'move') {
                    cropState.x = Math.max(0, Math.min(1 - startCrop.w, startCrop.x + dx));
                    cropState.y = Math.max(0, Math.min(1 - startCrop.h, startCrop.y + dy));
                } else {
                    let nx = startCrop.x, ny = startCrop.y, nw = startCrop.w, nh = startCrop.h;

                    if (dragMode.includes('w')) {
                        const newX = Math.max(0, Math.min(startCrop.x + startCrop.w - minSize, startCrop.x + dx));
                        nw = startCrop.w - (newX - startCrop.x);
                        nx = newX;
                    }
                    if (dragMode.includes('e')) {
                        nw = Math.max(minSize, Math.min(1 - startCrop.x, startCrop.w + dx));
                    }
                    if (dragMode.includes('n')) {
                        const newY = Math.max(0, Math.min(startCrop.y + startCrop.h - minSize, startCrop.y + dy));
                        nh = startCrop.h - (newY - startCrop.y);
                        ny = newY;
                    }
                    if (dragMode.includes('s')) {
                        nh = Math.max(minSize, Math.min(1 - startCrop.y, startCrop.h + dy));
                    }

                    cropState.x = nx;
                    cropState.y = ny;
                    cropState.w = nw;
                    cropState.h = nh;
                }

                updateCropSelection();
            }

            function onEnd() {
                dragMode = null;
            }

            // Mouse events on the entire preview content
            previewContent.addEventListener('mousedown', onStart);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);

            // Touch events
            previewContent.addEventListener('touchstart', onStart, {passive: false});
            document.addEventListener('touchmove', onMove, {passive: false});
            document.addEventListener('touchend', onEnd);

            // Store cleanup function
            cropState._cleanup = () => {
                previewContent.removeEventListener('mousedown', onStart);
                document.removeEventListener('mousemove', onMove);
                document.removeEventListener('mouseup', onEnd);
                previewContent.removeEventListener('touchstart', onStart);
                document.removeEventListener('touchmove', onMove);
                document.removeEventListener('touchend', onEnd);
            };
        }

        async function applyCrop() {
            if (!cropState) return;
            const crop = {
                x: Math.round(cropState.x * 1000) / 1000,
                y: Math.round(cropState.y * 1000) / 1000,
                w: Math.round(cropState.w * 1000) / 1000,
                h: Math.round(cropState.h * 1000) / 1000
            };

            // Skip if it's the full image (no actual crop)
            const isFullImage = crop.x === 0 && crop.y === 0 && crop.w === 1 && crop.h === 1;
            const saveCrop = isFullImage ? null : crop;

            const fn = cropState.filename;
            if (cropState._cleanup) cropState._cleanup();
            cropState = null;

            const img = images.find(i => i.filename === fn);
            if (img) img.crop = saveCrop;

            await updateImageField(fn, 'crop', saveCrop);
            renderSinglePreviewImage(fn);
            renderSingleControls(fn);
        }

        function cancelCrop() {
            if (!cropState) return;
            const fn = cropState.filename;
            if (cropState._cleanup) cropState._cleanup();
            cropState = null;
            renderSinglePreviewImage(fn);
            renderSingleControls(fn);
        }

        async function clearCrop(filename) {
            const img = images.find(i => i.filename === filename);
            if (img) img.crop = null;
            await updateImageField(filename, 'crop', null);
            renderSinglePreviewImage(filename);
            renderSingleControls(filename);
        }

        function openGroupPreview(groupId) {
            const group = groups[groupId];
            if (!group) return;

            previewGroupId = groupId;
            previewFilename = null;

            // Make section visible FIRST so container has real dimensions
            previewControls.classList.add('active');
            previewSection.classList.add('has-controls');
            previewSection.classList.add('active');
            document.querySelector('.preview-controls-actions').style.display = '';

            // Now render (container clientWidth/clientHeight are non-zero)
            renderGroupPreviewImage(groupId);
            renderGroupControls(groupId);
        }

        function renderGroupPreviewImage(groupId) {
            const group = groups[groupId];
            if (!group) return;

            const matColor = group.mat_color || matColorInput.value;
            const finish = group.mat_finish || matFinishSelect.value;
            const groupEffectSize = group.bevel_width ?? parseInt(bevelWidthInput.value);
            const groupBorderEffect = group.border_effect || borderEffectSelect.value;

            matPreview.style.backgroundColor = matColor;
            matPreview.classList.remove('mat-linen', 'mat-suede', 'mat-silk');
            if (finish !== 'flat') matPreview.classList.add('mat-' + finish);

            const groupImages = (group.images || []).map(f => images.find(i => i.filename === f)).filter(Boolean);
            const scales = group.scales || {};
            const count = groupImages.length;

            if (count <= 3) {
                // Compute explicit pixel sizes so all images render at the same height (when scale=1)
                const containerW = matPreview.clientWidth;
                const containerH = matPreview.clientHeight;
                const effectSpace = groupBorderEffect === 'shadow' ? Math.round(groupEffectSize * 2) : groupEffectSize;
                const effect2 = (effectSpace > 0 ? effectSpace : 0) * 2;

                const imgInfos = groupImages.map(img => ({
                    filename: img.filename,
                    ar: (img.width || 1) / (img.height || 1),
                    scale: scales[img.filename] || 1.0
                }));

                // At base height h=1, each image has width = ar * scale
                const totalWidthAtUnitHeight = imgInfos.reduce((sum, info) => sum + info.ar * info.scale, 0);
                const maxScale = Math.max(...imgInfos.map(i => i.scale));
                // Reserve space for N+1 equal gaps (space-evenly) ‚Äî each gap ~5% of container
                const gapFraction = 0.05;
                const totalGapFraction = gapFraction * (count + 1);
                // Subtract effect space from usable area
                const totalEffectW = effect2 * count;
                const usableW = containerW * (1 - totalGapFraction) - totalEffectW;
                const usableH = containerH * 0.85 - effect2;
                // Base height: largest h such that total width fits and tallest image fits
                const baseHeight = Math.min(usableH / maxScale, usableW / totalWidthAtUnitHeight);

                previewContent.innerHTML = `<div class="group-preview-images">${imgInfos.map(info => {
                    const h = baseHeight * info.scale;
                    const w = h * info.ar;
                    const imgHtml = `<img src="/uploads/${info.filename}" alt="${info.filename}" style="width:${w}px;height:${h}px;max-width:none;max-height:none;flex-shrink:0;">`;
                    return makeEffectHtml(imgHtml, groupEffectSize, matColor, groupBorderEffect);
                }).join('')}</div>`;
            } else {
                const cols = Math.ceil(Math.sqrt(count));
                previewContent.innerHTML = `<div class="group-preview-grid" style="grid-template-columns:repeat(${cols},1fr);">${groupImages.map(img => {
                    const imgHtml = `<img src="/uploads/${img.filename}" alt="${img.filename}">`;
                    return makeEffectHtml(imgHtml, groupEffectSize, matColor, groupBorderEffect);
                }).join('')}</div>`;
            }
        }

        function renderGroupControls(groupId) {
            const group = groups[groupId];
            if (!group) return;

            const groupImages = (group.images || []).map(f => images.find(i => i.filename === f)).filter(Boolean);
            const scales = group.scales || {};
            const count = groupImages.length;
            const currentFinish = group.mat_finish || '';
            const currentBevel = group.bevel_width ?? '';
            const currentBorderEffect = group.border_effect || '';
            const effectLabel = (currentBorderEffect || borderEffectSelect.value) === 'shadow' ? 'Shadow' : 'Bevel';

            previewControlsTitle.textContent = `Group (${count} images)`;

            const groupSettingsHtml = `
                <div class="group-edit-item" style="flex-wrap:wrap;gap:12px;padding-bottom:12px;margin-bottom:8px;border-bottom:1px solid rgba(255,255,255,0.1);">
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">Finish:</label>
                        <select style="flex:1;padding:6px;border:1px solid rgba(255,255,255,0.1);border-radius:6px;background:rgba(0,0,0,0.3);color:#e0e0e0;font-size:0.8rem;"
                                onchange="updateGroupField('${groupId}','mat_finish',this.value||null)">
                            <option value="" ${!currentFinish ? 'selected' : ''}>Default</option>
                            <option value="flat" ${currentFinish==='flat' ? 'selected' : ''}>Flat</option>
                            <option value="linen" ${currentFinish==='linen' ? 'selected' : ''}>Linen</option>
                            <option value="suede" ${currentFinish==='suede' ? 'selected' : ''}>Suede</option>
                            <option value="silk" ${currentFinish==='silk' ? 'selected' : ''}>Silk</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">Effect:</label>
                        <select style="flex:1;padding:6px;border:1px solid rgba(255,255,255,0.1);border-radius:6px;background:rgba(0,0,0,0.3);color:#e0e0e0;font-size:0.8rem;"
                                onchange="updateGroupField('${groupId}','border_effect',this.value||null); renderGroupControls('${groupId}')">
                            <option value="" ${!currentBorderEffect ? 'selected' : ''}>Default</option>
                            <option value="bevel" ${currentBorderEffect==='bevel' ? 'selected' : ''}>Bevel</option>
                            <option value="shadow" ${currentBorderEffect==='shadow' ? 'selected' : ''}>Shadow</option>
                        </select>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;flex:1;min-width:150px;">
                        <label style="font-size:0.8rem;color:#aaa;white-space:nowrap;">${effectLabel}: <span id="group-bevel-val">${currentBevel !== '' ? currentBevel + 'px' : parseInt(bevelWidthInput.value) + 'px'}</span></label>
                        <input type="range" min="0" max="16" step="1" value="${currentBevel !== '' ? currentBevel : parseInt(bevelWidthInput.value)}"
                               style="flex:1;accent-color:#00d4ff;"
                               oninput="this.previousElementSibling.querySelector('span').textContent = this.value + 'px'; previewGroupBevel('${groupId}', this.value)"
                               onchange="updateGroupField('${groupId}','bevel_width',parseInt(this.value))">
                    </div>
                </div>
            `;

            const imageControlsHtml = groupImages.map((img, idx) => `
                <div class="group-edit-item">
                    <img class="group-edit-thumb" src="/uploads/${img.filename}" alt="${img.filename}">
                    <div class="group-edit-controls">
                        <button class="move-btn" ${idx === 0 ? 'disabled' : ''} onclick="moveGroupImage('${groupId}', ${idx}, -1)" title="Move left">&larr;</button>
                        <input type="range" min="0.25" max="3" step="0.05"
                               value="${scales[img.filename] || 1.0}"
                               oninput="updateGroupScalePreview('${groupId}', '${img.filename}', this.value); this.nextElementSibling.textContent = parseFloat(this.value).toFixed(2) + 'x'"
                               onchange="updateGroupScale('${groupId}', '${img.filename}', this.value)">
                        <span class="scale-value">${parseFloat(scales[img.filename] || 1.0).toFixed(2)}x</span>
                        <button class="move-btn" ${idx === count - 1 ? 'disabled' : ''} onclick="moveGroupImage('${groupId}', ${idx}, 1)" title="Move right">&rarr;</button>
                    </div>
                </div>
            `).join('');

            previewControlsBody.innerHTML = groupSettingsHtml + imageControlsHtml;
        }

        function refreshPreview() {
            if (previewGroupId) {
                renderGroupPreviewImage(previewGroupId);
            }
        }

        async function autoMatchHeights() {
            if (!previewGroupId) return;
            const group = groups[previewGroupId];
            if (!group) return;

            const groupImages = (group.images || []).map(f => images.find(i => i.filename === f)).filter(Boolean);
            if (groupImages.length < 2) return;

            // Set all scales to 1.0 ‚Äî the explicit sizing logic in renderGroupPreviewImage
            // already ensures equal heights when all scales are the same
            const newScales = {};
            groupImages.forEach(img => {
                newScales[img.filename] = 1.0;
            });

            group.scales = newScales;

            try {
                await fetch(`/api/groups/${previewGroupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scales: newScales })
                });
                renderGroupControls(previewGroupId);
                renderGroupPreviewImage(previewGroupId);
                showStatus('Heights matched', 'success');
            } catch (err) {
                showStatus('Failed to match heights', 'error');
            }
        }

        function closePreview() {
            previewSection.classList.remove('active');
            previewSection.classList.remove('has-controls');
            previewControls.classList.remove('active');
            document.querySelector('.preview-controls-actions').style.display = '';
            previewFilename = null;
            previewGroupId = null;
        }

        // ===== Helpers =====
        function escAttr(str) {
            return String(str).replace(/[&"'<>]/g, c => ({'&':'&amp;','"':'&quot;',"'":'&#39;','<':'&lt;','>':'&gt;'}[c]));
        }

        function cleanFilename(filename) {
            return filename.replace(/^[a-f0-9]+_/, '');
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function updateStats() {
            const total = images.length;
            const enabled = images.filter(img => img.enabled).length;
            document.getElementById('total-count').textContent = total;
            document.getElementById('enabled-count').textContent = enabled;
            document.getElementById('disabled-count').textContent = total - enabled;
        }

        // ===== Selection & Select Mode =====
        let selectMode = false;

        function handleCardClick(filename) {
            if (selectMode) {
                toggleSelect(filename);
            } else {
                openPreview(filename);
            }
        }

        function toggleSelectMode() {
            selectMode = !selectMode;
            document.body.classList.toggle('select-mode', selectMode);
            const btn = document.getElementById('toggle-select-mode');
            btn.textContent = selectMode ? 'Done' : 'Select';
            btn.classList.toggle('btn-warning', selectMode);
            btn.classList.toggle('btn-edit', !selectMode);

            const toolbarRight = document.querySelector('.toolbar-right');
            const countWrapper = document.getElementById('selection-count-wrapper');
            if (selectMode) {
                toolbarRight.style.display = '';
                countWrapper.style.display = '';
            } else {
                toolbarRight.style.display = 'none';
                countWrapper.style.display = 'none';
                selectedImages.clear();
                updateSelectionUI();
            }
        }

        function toggleSelect(filename) {
            if (selectedImages.has(filename)) {
                selectedImages.delete(filename);
            } else {
                selectedImages.add(filename);
            }
            updateSelectionUI();
        }

        function updateSelectionUI() {
            document.getElementById('selected-count').textContent = selectedImages.size;

            const hasSelection = selectedImages.size > 0;
            document.getElementById('bulk-enable').disabled = !hasSelection;
            document.getElementById('bulk-disable').disabled = !hasSelection;
            document.getElementById('bulk-delete').disabled = !hasSelection;
            document.getElementById('bulk-group').disabled = selectedImages.size < 2;

            document.querySelectorAll('.image-card').forEach(card => {
                const filename = card.dataset.filename;
                card.classList.toggle('selected', selectedImages.has(filename));
            });
        }

        function getFilteredImages() {
            if (currentFilter === 'enabled') return images.filter(img => img.enabled);
            if (currentFilter === 'disabled') return images.filter(img => !img.enabled);
            return images;
        }

        // Filter tabs
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentFilter = tab.dataset.filter;
                renderGallery();
            });
        });

        // ===== Image Actions =====
        async function updateMatColor(filename, color) {
            try {
                const response = await fetch(`/api/gallery/${filename}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mat_color: color })
                });
                if (response.ok) {
                    const img = images.find(i => i.filename === filename);
                    if (img) img.mat_color = color;
                    // Update preview if this image is being previewed
                    if (previewFilename === filename) {
                        renderSinglePreviewImage(filename);
                    }
                    showStatus('Mat color updated', 'success');
                }
            } catch (err) {
                showStatus('Failed to update mat color', 'error');
            }
        }

        async function toggleImage(filename, enabled) {
            try {
                const response = await fetch(`/api/gallery/${filename}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ enabled })
                });
                if (response.ok) {
                    const img = images.find(i => i.filename === filename);
                    if (img) img.enabled = enabled;
                    renderGallery();
                    updateStats();
                    showStatus(enabled ? 'Image visible' : 'Image hidden', 'success');
                }
            } catch (err) {
                showStatus('Failed to update image', 'error');
            }
        }

        async function deleteImage(filename) {
            if (!confirm('Delete this image permanently?')) return;

            try {
                const response = await fetch(`/api/gallery/${filename}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    images = images.filter(i => i.filename !== filename);
                    selectedImages.delete(filename);
                    if (previewFilename === filename) closePreview();
                    renderGallery();
                    updateStats();
                    showStatus('Image deleted', 'success');
                }
            } catch (err) {
                showStatus('Failed to delete image', 'error');
            }
        }

        // ===== Bulk Actions =====
        document.getElementById('bulk-enable').addEventListener('click', () => bulkAction('enable'));
        document.getElementById('bulk-disable').addEventListener('click', () => bulkAction('disable'));
        document.getElementById('bulk-delete').addEventListener('click', async () => {
            if (!confirm(`Delete ${selectedImages.size} images permanently?`)) return;
            await bulkAction('delete');
        });

        async function bulkAction(action) {
            const filenames = Array.from(selectedImages);
            try {
                const response = await fetch('/api/gallery/bulk', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action, filenames })
                });
                const data = await response.json();
                if (response.ok) {
                    showStatus(data.message, 'success');
                    if (action === 'delete') {
                        images = images.filter(i => !filenames.includes(i.filename));
                        if (filenames.includes(previewFilename)) closePreview();
                    } else {
                        filenames.forEach(f => {
                            const img = images.find(i => i.filename === f);
                            if (img) img.enabled = (action === 'enable');
                        });
                    }
                    selectedImages.clear();
                    renderGallery();
                    updateStats();
                }
            } catch (err) {
                showStatus('Action failed', 'error');
            }
        }

        // ===== Group Actions =====
        document.getElementById('bulk-group').addEventListener('click', createGroup);

        async function createGroup() {
            const filenames = Array.from(selectedImages);
            if (filenames.length < 2) return;

            try {
                const response = await fetch('/api/groups', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ images: filenames })
                });
                if (response.ok) {
                    selectedImages.clear();
                    showStatus(`Created group with ${filenames.length} images`, 'success');
                    loadGallery();
                }
            } catch (err) {
                showStatus('Failed to create group', 'error');
            }
        }

        async function ungroupGroup(groupId) {
            try {
                const response = await fetch(`/api/groups/${groupId}`, {
                    method: 'DELETE'
                });
                if (response.ok) {
                    if (previewGroupId === groupId) closePreview();
                    showStatus('Group dissolved', 'success');
                    loadGallery();
                }
            } catch (err) {
                showStatus('Failed to ungroup', 'error');
            }
        }

        async function deleteGroup(groupId) {
            const group = groups[groupId];
            if (!group) return;
            if (!confirm(`Delete this group and all ${group.images.length} images permanently?`)) return;

            try {
                // Delete each image in the group
                for (const filename of group.images) {
                    await fetch(`/api/gallery/${filename}`, { method: 'DELETE' });
                }
                // Then delete the group itself
                await fetch(`/api/groups/${groupId}`, { method: 'DELETE' });
                if (previewGroupId === groupId) closePreview();
                showStatus('Group and images deleted', 'success');
                loadGallery();
            } catch (err) {
                showStatus('Failed to delete group', 'error');
            }
        }

        function updateGroupScalePreview(groupId, filename, scaleValue) {
            const group = groups[groupId];
            if (!group) return;
            if (!group.scales) group.scales = {};
            group.scales[filename] = parseFloat(scaleValue);
            renderGroupPreviewImage(groupId);
        }

        async function updateGroupScale(groupId, filename, scaleValue) {
            const group = groups[groupId];
            if (!group) return;

            if (!group.scales) group.scales = {};
            group.scales[filename] = parseFloat(scaleValue);

            try {
                await fetch(`/api/groups/${groupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scales: group.scales })
                });
                renderGroupPreviewImage(groupId);
            } catch (err) {
                showStatus('Failed to update scale', 'error');
            }
        }

        function updateSingleScalePreview(filename, scaleValue) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;
            img.scale = parseFloat(scaleValue);
            renderSinglePreviewImage(filename);
        }

        async function updateSingleScale(filename, scaleValue) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;
            img.scale = parseFloat(scaleValue);
            try {
                await fetch(`/api/gallery/${filename}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ scale: img.scale })
                });
                renderSinglePreviewImage(filename);
            } catch (err) {
                showStatus('Failed to update scale', 'error');
            }
        }

        async function moveGroupImage(groupId, currentIdx, direction) {
            const group = groups[groupId];
            if (!group) return;

            const imgs = [...group.images];
            const newIdx = currentIdx + direction;
            if (newIdx < 0 || newIdx >= imgs.length) return;

            // Swap
            [imgs[currentIdx], imgs[newIdx]] = [imgs[newIdx], imgs[currentIdx]];
            group.images = imgs;

            try {
                const response = await fetch(`/api/groups/${groupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ images: imgs })
                });
                if (response.ok) {
                    renderGallery();
                    // Re-render controls and preview
                    renderGroupControls(groupId);
                    renderGroupPreviewImage(groupId);
                }
            } catch (err) {
                showStatus('Failed to reorder images', 'error');
            }
        }

        async function updateGroupMatColor(groupId, color) {
            try {
                const response = await fetch(`/api/groups/${groupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mat_color: color })
                });
                if (response.ok) {
                    groups[groupId].mat_color = color;
                    if (previewGroupId === groupId) {
                        matPreview.style.backgroundColor = color;
                    }
                    showStatus('Group mat color updated', 'success');
                }
            } catch (err) {
                showStatus('Failed to update group mat color', 'error');
            }
        }

        async function updateGroupField(groupId, field, value) {
            const group = groups[groupId];
            if (!group) return;
            group[field] = value;

            try {
                await fetch(`/api/groups/${groupId}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [field]: value })
                });
                renderGroupPreviewImage(groupId);
                showStatus(`Group ${field.replace('_', ' ')} updated`, 'success');
            } catch (err) {
                showStatus(`Failed to update group ${field}`, 'error');
            }
        }

        function previewGroupBevel(groupId, val) {
            const group = groups[groupId];
            if (!group) return;
            // Temporarily set for preview
            const origBevel = group.bevel_width;
            group.bevel_width = val == -1 ? undefined : parseInt(val);
            renderGroupPreviewImage(groupId);
            group.bevel_width = origBevel;
        }

        // ===== Settings =====
        function updatePreviewAspectRatio() {
            const ratio = targetAspectRatioSelect.value || '16:9';
            matPreview.style.setProperty('--preview-aspect-ratio', ratio.replace(':', '/'));
        }

        function saveSlideshowSettings() {
            const settings = {
                slideshow_interval: parseInt(slideshowIntervalInput.value),
                transition_duration: parseFloat(transitionDurationInput.value),
                fit_mode: fitModeSelect.value,
                shuffle: shuffleCheckbox.checked,
                target_aspect_ratio: targetAspectRatioSelect.value
            };

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            });
        }

        function applyMatSettings() {
            const settings = {
                mat_color: matColorInput.value,
                mat_finish: matFinishSelect.value,
                bevel_width: parseInt(bevelWidthInput.value),
                border_effect: borderEffectSelect.value
            };

            fetch('/api/settings', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(settings)
            }).then(() => {
                showStatus('Mat settings applied', 'success');
                // Re-render preview if an image/group is shown and uses defaults
                if (previewFilename) {
                    const img = images.find(i => i.filename === previewFilename);
                    if (img && !img.mat_color) renderSinglePreviewImage(previewFilename);
                } else if (previewGroupId) {
                    const group = groups[previewGroupId];
                    if (group && !group.mat_color) renderGroupPreviewImage(previewGroupId);
                }
            }).catch(() => {
                showStatus('Failed to apply mat settings', 'error');
            });

            updateColorPresets();
            updatePreviewTexture();
        }

        // Mat settings: Apply button (not auto-save)
        document.getElementById('apply-mat-settings').addEventListener('click', applyMatSettings);

        // Live preview updates for mat settings (no save)
        matFinishSelect.addEventListener('change', updatePreviewTexture);
        borderEffectSelect.addEventListener('change', () => {
            effectSizeLabel.textContent = borderEffectSelect.value === 'shadow' ? 'Shadow' : 'Bevel';
        });
        bevelWidthInput.addEventListener('input', () => {
            bevelValueLabel.textContent = bevelWidthInput.value + 'px';
        });

        // Color presets select color but don't save (Apply button saves)
        colorPresets.forEach(preset => {
            preset.addEventListener('click', () => {
                matColorInput.value = preset.dataset.color;
                updateColorPresets();
                updatePreviewTexture();
            });
        });

        // Slideshow settings: auto-save
        slideshowIntervalInput.addEventListener('change', saveSlideshowSettings);
        transitionDurationInput.addEventListener('change', saveSlideshowSettings);
        fitModeSelect.addEventListener('change', saveSlideshowSettings);
        shuffleCheckbox.addEventListener('change', saveSlideshowSettings);
        targetAspectRatioSelect.addEventListener('change', () => {
            saveSlideshowSettings();
            updatePreviewAspectRatio();
        });

        function updateColorPresets() {
            colorPresets.forEach(preset => {
                preset.classList.toggle('active', preset.dataset.color === matColorInput.value);
            });
        }
        updateColorPresets();

        // ===== Per-image Field Updates =====
        async function updateImageField(filename, field, value) {
            const img = images.find(i => i.filename === filename);
            if (img) img[field] = value;

            try {
                await fetch(`/api/gallery/${filename}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ [field]: value })
                });
                // Re-render preview
                if (previewFilename === filename) renderSinglePreviewImage(filename);
                showStatus(`${field.replace('_', ' ')} updated`, 'success');
            } catch (err) {
                showStatus(`Failed to update ${field}`, 'error');
            }
        }

        function previewSingleBevel(filename, val) {
            const img = images.find(i => i.filename === filename);
            if (!img) return;
            // Temporarily override bevel_width for preview, then render normally
            const savedBevel = img.bevel_width;
            img.bevel_width = parseInt(val);
            renderSinglePreviewImage(filename);
            img.bevel_width = savedBevel;
        }

        // ===== Bevel + Texture Helpers =====
        function getBevelColors(matHex) {
            let hex = matHex.replace('#', '');
            if (hex.length === 3) hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
            const r = parseInt(hex.substring(0, 2), 16);
            const g = parseInt(hex.substring(2, 4), 16);
            const b = parseInt(hex.substring(4, 6), 16);
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            // Visible bevel shading - consistent on both faces
            const lightAlpha = luminance < 0.5 ? 0.13 : 0.07;
            const darkAlpha = luminance < 0.5 ? 0.22 : 0.16;
            return {
                light: `rgba(255,255,255,${lightAlpha})`,
                dark: `rgba(0,0,0,${darkAlpha})`
            };
        }

        function makeMiterLineHtml(b) {
            const diag = (Math.sqrt(2) * b).toFixed(1);
            const style = 'position:absolute;height:0;border-top:0.5px solid rgba(0,0,0,0.08);pointer-events:none;z-index:2;';
            return [
                `<div style="${style}top:0;left:0;width:${diag}px;transform-origin:0 0;transform:rotate(45deg);"></div>`,
                `<div style="${style}top:0;right:0;width:${diag}px;transform-origin:100% 0;transform:rotate(-45deg);"></div>`,
                `<div style="${style}bottom:0;left:0;width:${diag}px;transform-origin:0 100%;transform:rotate(-45deg);"></div>`,
                `<div style="${style}bottom:0;right:0;width:${diag}px;transform-origin:100% 100%;transform:rotate(45deg);"></div>`,
            ].join('');
        }

        function getShadowStyle(size) {
            const blur = size * 2;
            const spread = Math.round(size * 0.5);
            const yOffset = Math.round(size * 0.5);
            return `0 ${yOffset}px ${blur}px ${spread}px rgba(0,0,0,0.35)`;
        }

        function makeBevelHtml(innerHtml, bevelWidth, matColor) {
            if (!bevelWidth || bevelWidth <= 0) return innerHtml;
            const colors = getBevelColors(matColor);
            return `<div class="mat-bevel" style="--bevel-w:${bevelWidth}px;--bevel-light:${colors.light};--bevel-dark:${colors.dark}">${innerHtml}${makeMiterLineHtml(bevelWidth)}</div>`;
        }

        function makeEffectHtml(innerHtml, effectSize, matColor, borderEffect) {
            if (!effectSize || effectSize <= 0) return innerHtml;
            if (borderEffect === 'shadow') {
                const shadow = getShadowStyle(effectSize);
                // Wrap in shadow container and apply box-shadow to the inner element
                if (innerHtml.includes('style="')) {
                    return `<div class="mat-shadow">${innerHtml.replace('style="', 'style="box-shadow:' + shadow + ';')}</div>`;
                }
                return `<div class="mat-shadow" style="box-shadow:${shadow};display:inline-flex;line-height:0;">${innerHtml}</div>`;
            }
            return makeBevelHtml(innerHtml, effectSize, matColor);
        }

        function updatePreviewTexture() {
            const finish = matFinishSelect.value;
            matPreview.classList.remove('mat-linen', 'mat-suede', 'mat-silk');
            if (finish !== 'flat') {
                matPreview.classList.add('mat-' + finish);
            }
        }

        // ===== Status Messages =====
        function showStatus(message, type) {
            statusEl.textContent = message;
            statusEl.className = 'status ' + type;
            setTimeout(() => {
                statusEl.className = 'status';
            }, 3000);
        }

        // ===== TV Schedules =====
        const DAY_LABELS = ['M', 'T', 'W', 'T', 'F', 'S', 'S'];
        const DAY_NAMES = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
        let tvSchedules = [];

        async function loadTvSchedules() {
            try {
                const resp = await fetch('/api/tv-schedules');
                const data = await resp.json();
                tvSchedules = data.schedules || [];
                const cecAvailable = data.cec_available;

                document.getElementById('cec-unavailable-msg').style.display =
                    cecAvailable ? 'none' : 'block';
                document.getElementById('cec-controls').style.display =
                    cecAvailable ? 'block' : 'none';

                renderTvSchedules();
            } catch (err) {
                console.error('Failed to load TV schedules:', err);
            }
        }

        function renderTvSchedules() {
            const list = document.getElementById('tv-schedule-list');
            list.innerHTML = tvSchedules.map((sched, idx) => `
                <div class="tv-schedule-item">
                    <div class="tv-schedule-times">
                        <input type="time" value="${sched.on_time}"
                               onchange="updateScheduleField(${idx}, 'on_time', this.value)">
                        <span>to</span>
                        <input type="time" value="${sched.off_time}"
                               onchange="updateScheduleField(${idx}, 'off_time', this.value)">
                    </div>
                    <div class="tv-schedule-days">
                        ${DAY_LABELS.map((label, d) => `
                            <div class="day-checkbox${sched.days.includes(d) ? ' active' : ''}"
                                 title="${DAY_NAMES[d]}"
                                 onclick="toggleScheduleDay(${idx}, ${d})">${label}</div>
                        `).join('')}
                    </div>
                    <div class="tv-schedule-actions">
                        <label class="toggle" style="transform: scale(0.8);">
                            <input type="checkbox" ${sched.enabled ? 'checked' : ''}
                                   onchange="updateScheduleField(${idx}, 'enabled', this.checked)">
                            <span class="toggle-slider"></span>
                        </label>
                        <button class="btn btn-refresh" onclick="removeTvSchedule(${idx})"
                                style="padding: 4px 10px; font-size: 0.75rem;">Remove</button>
                    </div>
                </div>
            `).join('');
        }

        function addTvSchedule() {
            tvSchedules.push({
                id: 'sched_' + Math.random().toString(36).substr(2, 8),
                on_time: '07:00',
                off_time: '23:00',
                days: [0, 1, 2, 3, 4, 5, 6],
                enabled: true
            });
            renderTvSchedules();
            saveTvSchedules();
        }

        function removeTvSchedule(idx) {
            tvSchedules.splice(idx, 1);
            renderTvSchedules();
            saveTvSchedules();
        }

        function updateScheduleField(idx, field, value) {
            tvSchedules[idx][field] = value;
            saveTvSchedules();
        }

        function toggleScheduleDay(idx, day) {
            const days = tvSchedules[idx].days;
            const pos = days.indexOf(day);
            if (pos >= 0) {
                days.splice(pos, 1);
            } else {
                days.push(day);
                days.sort();
            }
            renderTvSchedules();
            saveTvSchedules();
        }

        async function saveTvSchedules() {
            try {
                await fetch('/api/tv-schedules', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ schedules: tvSchedules })
                });
            } catch (err) {
                showStatus('Failed to save TV schedules', 'error');
            }
        }

        async function testCec(command) {
            try {
                const resp = await fetch('/api/cec/test', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ command })
                });
                const data = await resp.json();
                if (data.success) {
                    showStatus(`TV ${command === 'on' ? 'on' : 'off'} command sent`, 'success');
                } else {
                    showStatus('CEC failed: ' + (data.error || 'Unknown error'), 'error');
                }
            } catch (err) {
                showStatus('CEC test failed', 'error');
            }
        }

        loadTvSchedules();

        // ===== Network Info =====
        {% if is_admin and password_changed %}
        (async function loadNetworkInfo() {
            try {
                const resp = await fetch('/api/network-info');
                if (!resp.ok) return;
                const info = await resp.json();
                const el = document.getElementById('network-info-content');
                if (!el) return;
                let html = '';
                if (info.local_ip) {
                    html += `<div style="margin-bottom: 6px;"><strong>Local IP:</strong> ${info.local_ip}</div>`;
                }
                if (info.tailscale_ip) {
                    html += `<div style="margin-bottom: 6px;"><strong>Tailscale IP:</strong> ${info.tailscale_ip}</div>`;
                }
                if (!info.local_ip && !info.tailscale_ip) {
                    html = 'No network info available.';
                }
                el.innerHTML = html;
            } catch (err) {
                const el = document.getElementById('network-info-content');
                if (el) el.textContent = 'Could not load network info.';
            }
        })();
        {% endif %}
    </script>

    <!-- Upload Warning Modal -->
    <div class="upload-modal-overlay" id="upload-modal-overlay">
        <div class="upload-modal">
            <h3>Review Uploads</h3>
            <div id="upload-modal-body"></div>
            <div class="upload-modal-actions">
                <button class="btn-upload-cancel" onclick="cancelUploadModal()">Cancel</button>
                <button class="btn-upload-proceed" id="btn-upload-proceed" onclick="proceedUpload()">Upload Selected</button>
            </div>
        </div>
    </div>
</body>
</html>
